<script>
  document.addEventListener("DOMContentLoaded", () => {
    const windows = document.querySelectorAll<HTMLDivElement>(".window");
    let activeWindow: HTMLDivElement | null = null;
    let selectedWindow: HTMLDivElement | null = null;
    const gaps = 12;

    // Window focus management
    windows.forEach((window) => {
      window.addEventListener("mousedown", () => {
        windows.forEach((w) => (w.style.zIndex = "1"));
        window.style.zIndex = "10";
        setActiveWindow(window);
      });
    });

    function setActiveWindow(window: HTMLDivElement | null) {
      windows.forEach((w) => w.classList.remove("active-window"));
      activeWindow = window;
      if (activeWindow) {
        activeWindow.classList.add("active-window");
      }
    }

    function setSelectedWindow(window: HTMLDivElement | null) {
      windows.forEach((w) => w.classList.remove("selected-window"));
      selectedWindow = window;
      if (selectedWindow) {
        selectedWindow.classList.add("selected-window");
      }
    }

    // Window management with keyboard
    document.addEventListener("keydown", (e) => {
      if (!activeWindow && !selectedWindow) return;

      const workspace = document.querySelector<HTMLElement>("main");
      if (!workspace) return;

      // Select windows with Shift + Arrow keys
      if (e.shiftKey) {
        e.preventDefault();
        const currentWindow = selectedWindow || activeWindow;
        if (!currentWindow) return;

        const currentRect = currentWindow.getBoundingClientRect();
        const otherWindows = Array.from(windows).filter(
          (w) => w !== currentWindow
        );

        let nextWindow: HTMLDivElement | null = null;
        let minDistance = Infinity;

        otherWindows.forEach((window) => {
          const rect = window.getBoundingClientRect();

          switch (e.key) {
            case "ArrowLeft": {
              if (
                rect.right < currentRect.left &&
                rect.top < currentRect.bottom &&
                rect.bottom > currentRect.top
              ) {
                const distance = currentRect.left - rect.right;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
            case "ArrowRight": {
              if (
                rect.left > currentRect.right &&
                rect.top < currentRect.bottom &&
                rect.bottom > currentRect.top
              ) {
                const distance = rect.left - currentRect.right;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
            case "ArrowUp": {
              if (
                rect.bottom < currentRect.top &&
                rect.left < currentRect.right &&
                rect.right > currentRect.left
              ) {
                const distance = currentRect.top - rect.bottom;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
            case "ArrowDown": {
              if (
                rect.top > currentRect.bottom &&
                rect.left < currentRect.right &&
                rect.right > currentRect.left
              ) {
                const distance = rect.top - currentRect.bottom;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
          }
        });

        if (nextWindow) {
          setSelectedWindow(nextWindow);
          setActiveWindow(nextWindow);
        }
      }

      // Move windows with Alt + Arrow keys
      if (e.altKey) {
        e.preventDefault();
        const targetWindow = selectedWindow || activeWindow;
        if (!targetWindow) return;

        switch (e.key) {
          case "ArrowLeft":
            swapWithNeighbor(targetWindow, "left");
            break;
          case "ArrowRight":
            swapWithNeighbor(targetWindow, "right");
            break;
          case "ArrowUp":
            swapWithNeighbor(targetWindow, "up");
            break;
          case "ArrowDown":
            swapWithNeighbor(targetWindow, "down");
            break;
        }
      }

      // Resize windows with Ctrl + Arrow keys
      if (e.ctrlKey) {
        e.preventDefault();
        const targetWindow = selectedWindow || activeWindow;
        if (!targetWindow) return;

        const action = {
          ArrowLeft: "shrink-width",
          ArrowRight: "grow-width",
          ArrowUp: "shrink-height",
          ArrowDown: "grow-height",
        }[e.key] as
          | "grow-width"
          | "shrink-width"
          | "grow-height"
          | "shrink-height";

        if (action) {
          resizeWindowByPercent(targetWindow, action);
        }
      }
    });

    function swapWithNeighbor(
      window: HTMLDivElement,
      direction: "left" | "right" | "up" | "down"
    ) {
      const rect = window.getBoundingClientRect();
      const neighbors = Array.from(windows).filter((w) => w !== window);

      // Find the closest neighbor in the specified direction
      const neighbor = neighbors.reduce(
        (closest, current) => {
          const currentRect = current.getBoundingClientRect();

          // Check if the window is in the correct direction
          const isValidDirection =
            (direction === "left" && currentRect.right <= rect.left) ||
            (direction === "right" && currentRect.left >= rect.right) ||
            (direction === "up" && currentRect.bottom <= rect.top) ||
            (direction === "down" && currentRect.top >= rect.bottom);

          if (!isValidDirection) return closest;

          // Calculate distance between windows
          const distance = Math.hypot(
            currentRect.left +
              currentRect.width / 2 -
              (rect.left + rect.width / 2),
            currentRect.top +
              currentRect.height / 2 -
              (rect.top + rect.height / 2)
          );

          return !closest || distance < closest.distance
            ? { element: current, distance }
            : closest;
        },
        null as { element: HTMLDivElement; distance: number } | null
      );

      if (neighbor) {
        // Swap positions with the neighbor
        const windowPos = {
          left: window.style.left,
          top: window.style.top,
          width: window.style.width,
          height: window.style.height,
        };

        const neighborElement = neighbor.element;
        window.style.left = neighborElement.style.left;
        window.style.top = neighborElement.style.top;
        window.style.width = neighborElement.style.width;
        window.style.height = neighborElement.style.height;

        neighborElement.style.left = windowPos.left;
        neighborElement.style.top = windowPos.top;
        neighborElement.style.width = windowPos.width;
        neighborElement.style.height = windowPos.height;
      }
    }

    function resizeWindowByPercent(targetWindow: HTMLDivElement, action: 'grow-width' | 'shrink-width' | 'grow-height' | 'shrink-height') {
    console.log(`--- Resize Start ---`);
    console.log(`Action: ${action}, Target Window ID: ${targetWindow.id || 'No ID'}`);

    const workspace = document.querySelector<HTMLElement>('main');
    if (!workspace) { console.error("Workspace element not found!"); return; }
    const workspaceRect = workspace.getBoundingClientRect();
    const workspaceOffsetTop = workspaceRect.top;
    const workspaceOffsetLeft = workspaceRect.left;
    // console.log("Workspace Rect:", workspaceRect);

    // --- Configuration ---
    const percent = 0.05;
    const minSize = 50;
    const currentGaps = 8;
    // --- End Configuration ---

    const allWindows = Array.from(document.querySelectorAll<HTMLDivElement>('.window'));
    if (allWindows.length !== 4) { console.warn("Resize logic assumes exactly 4 windows."); return; }

    const initialViewportRects = new Map<HTMLDivElement, DOMRect>();
    allWindows.forEach((w, i) => {
        if (!w.id) w.id = `win${i}`;
        initialViewportRects.set(w, w.getBoundingClientRect());
    });
    // console.log("Initial Viewport Rects:", initialViewportRects);

    const targetViewportRect = initialViewportRects.get(targetWindow);
    if (!targetViewportRect) { console.error("Target window not found in initialViewportRects map."); return; }
    // console.log(`Target Viewport Rect (${targetWindow.id}):`, targetViewportRect);

    const targetIndex = allWindows.findIndex(w => w === targetWindow);
    if (targetIndex === -1) { console.error("Target window not found in allWindows array."); return; }
    console.log(`Target Index: ${targetIndex}`);

    let neighborIndex = -1;
    const isHorizontal = action.includes('width');
    const isShrinking = action.includes('shrink');

     if (action === 'grow-width') neighborIndex = (targetIndex === 0 || targetIndex === 2) ? targetIndex + 1 : -1;
     else if (action === 'shrink-width') neighborIndex = (targetIndex === 1 || targetIndex === 3) ? targetIndex - 1 : -1;
     else if (action === 'grow-height') neighborIndex = (targetIndex === 0 || targetIndex === 1) ? targetIndex + 2 : -1;
     else if (action === 'shrink-height') neighborIndex = (targetIndex === 2 || targetIndex === 3) ? targetIndex - 2 : -1;

    console.log(`Calculated Neighbor Index: ${neighborIndex}`);

    if (neighborIndex < 0 || neighborIndex >= 4) {
        console.log("No valid neighbor for this action/position.");
        console.log(`--- Resize End (No Neighbor) ---`);
        return;
    }

    const neighborWindow = allWindows[neighborIndex];
    const neighborViewportRect = initialViewportRects.get(neighborWindow);
    if (!neighborViewportRect) { console.error(`Neighbor window error.`); return; }
    // console.log(`Neighbor (${neighborWindow.id}) Viewport Rect:`, neighborViewportRect);

    const resizeAmountPx = isHorizontal ? workspaceRect.width * percent : workspaceRect.height * percent;
    // console.log(`Base Resize Amount (px): ${resizeAmountPx}`);

    let actualResizeAmountPx = 0;
    const shrinkingWindow = isShrinking ? targetWindow : neighborWindow;
    const growingWindow = isShrinking ? neighborWindow : targetWindow;
    const shrinkingViewportRect = initialViewportRects.get(shrinkingWindow)!;
    const growingViewportRect = initialViewportRects.get(growingWindow)!; // Get rect for growing window too

    console.log(`Shrinking Window: ${shrinkingWindow.id}, Growing Window: ${growingWindow.id}`);

    // Check constraints
    if (isHorizontal) {
        // console.log(`Checking Shrink Width: ${shrinkingWindow.id} width=${shrinkingViewportRect.width}`);
        if (shrinkingViewportRect.width >= minSize + resizeAmountPx) actualResizeAmountPx = resizeAmountPx;
        else actualResizeAmountPx = Math.max(0, shrinkingViewportRect.width - minSize);
    } else {
        // console.log(`Checking Shrink Height: ${shrinkingWindow.id} height=${shrinkingViewportRect.height}`);
        if (shrinkingViewportRect.height >= minSize + resizeAmountPx) actualResizeAmountPx = resizeAmountPx;
        else actualResizeAmountPx = Math.max(0, shrinkingViewportRect.height - minSize);
    }
    console.log(`Actual Resize Amount (px): ${actualResizeAmountPx}`);

    if (actualResizeAmountPx < 1 && !(action === 'shrink-height' && targetWindow.id === 'win2')) { // Allow test case even if amount is 0
        console.log("Resize blocked.");
        console.log(`--- Resize End (Blocked) ---`);
        return;
    }

    // --- Apply Changes ---
    console.log("Applying Changes...");

    // Get initial container-relative positions and dimensions for calculation reference
    let targetStyleLeft = targetViewportRect.left - workspaceOffsetLeft;
    let targetStyleTop = targetViewportRect.top - workspaceOffsetTop;
    let targetStyleWidth = targetViewportRect.width;
    let targetStyleHeight = targetViewportRect.height;

    let neighborStyleLeft = neighborViewportRect.left - workspaceOffsetLeft;
    let neighborStyleTop = neighborViewportRect.top - workspaceOffsetTop;
    let neighborStyleWidth = neighborViewportRect.width;
    let neighborStyleHeight = neighborViewportRect.height;

    // Calculate NEW dimensions AND positions based on action
    if (isHorizontal) {
        if (action === 'grow-width') { // Target(Left) grows, Neighbor(Right) shrinks
            targetStyleWidth += actualResizeAmountPx;
            neighborStyleWidth -= actualResizeAmountPx;
            neighborStyleLeft = targetStyleLeft + targetStyleWidth + currentGaps; // Neighbor moves right
        } else if (action === 'shrink-width') { // Target(Right) shrinks, Neighbor(Left) grows
            targetStyleWidth -= actualResizeAmountPx;
            neighborStyleWidth += actualResizeAmountPx;
            targetStyleLeft = neighborStyleLeft + neighborStyleWidth + currentGaps; // Target moves left
        }
    } else { // Vertical
        if (action === 'grow-height') { // Target(Top) grows, Neighbor(Bottom) shrinks
            targetStyleHeight += actualResizeAmountPx;
            neighborStyleHeight -= actualResizeAmountPx;
            neighborStyleTop = targetStyleTop + targetStyleHeight + currentGaps; // Neighbor moves down

        } else if (action === 'shrink-height') { // Target(Bottom) shrinks, Neighbor(Top) grows
            console.log("!!! EXECUTING shrink-height LOGIC !!!");

            // HARDCODED TEST for target=win2, neighbor=win0
            if (targetWindow.id === 'win2' && neighborWindow.id === 'win0') {
                 console.log("!!! APPLYING FORCED TEST for win2 shrink-height !!!");
                const shrinkAmount = 30; // Fixed amount for testing
                // Ensure calculations use initial values before applying test changes
                let initialTargetHeight = targetViewportRect.height;
                let initialNeighborHeight = neighborViewportRect.height;
                let initialNeighborStyleTop = neighborViewportRect.top - workspaceOffsetTop;

                targetStyleHeight = initialTargetHeight - shrinkAmount; // win2 shorter
                neighborStyleHeight = initialNeighborHeight + shrinkAmount; // win0 taller
                // Target(Bottom: win2) needs new top = Neighbor's(win0) initial top + Neighbor's NEW height + gap.
                targetStyleTop = initialNeighborStyleTop + neighborStyleHeight + currentGaps;

                console.log(`!!! TEST VALUES: win2.height=${targetStyleHeight}, win0.height=${neighborStyleHeight}, win2.top=${targetStyleTop} !!!`);
            } else {
                 // Original calculation (for other windows like win3 shrinking up)
                 console.log("!!! APPLYING Original shrink-height CALCULATION !!!");
                 targetStyleHeight -= actualResizeAmountPx; // Target height decreases
                 neighborStyleHeight += actualResizeAmountPx; // Neighbor height increases
                 // Target's new top = Neighbor's initial top + Neighbor's NEW height + gap.
                 targetStyleTop = neighborStyleTop + neighborStyleHeight + currentGaps;
            }
        }
    }

    // --- Log intended style changes ---
    console.log(`Setting ${targetWindow.id}: left=${targetStyleLeft}px, top=${targetStyleTop}px, width=${targetStyleWidth}px, height=${targetStyleHeight}px`);
    console.log(`Setting ${neighborWindow.id}: left=${neighborStyleLeft}px, top=${neighborStyleTop}px, width=${neighborStyleWidth}px, height=${neighborStyleHeight}px`);

    // --- Apply ALL Styles to BOTH windows ---
    targetWindow.style.left = `${targetStyleLeft}px`;
    targetWindow.style.top = `${targetStyleTop}px`;
    targetWindow.style.width = `${targetStyleWidth}px`;
    targetWindow.style.height = `${targetStyleHeight}px`;

    neighborWindow.style.left = `${neighborStyleLeft}px`;
    neighborWindow.style.top = `${neighborStyleTop}px`;
    neighborWindow.style.width = `${neighborStyleWidth}px`;
    neighborWindow.style.height = `${neighborStyleHeight}px`;

    console.log(`--- Resize End (Applied) ---`);
}
  });
</script>
