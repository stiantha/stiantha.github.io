<script>
  document.addEventListener('DOMContentLoaded', () => {
    const windows = document.querySelectorAll<HTMLElement>('.window');
    let activeWindow: HTMLElement | null = null;
    let selectedWindow: HTMLElement | null = null;
    const gaps = 12;

    // Window focus management
    windows.forEach(window => {
      window.addEventListener('mousedown', () => {
        windows.forEach(w => w.style.zIndex = '1');
        window.style.zIndex = '10';
        setActiveWindow(window);
      });
    });

    function setActiveWindow(window: HTMLElement | null) {
      windows.forEach(w => w.classList.remove('active-window'));
      activeWindow = window;
      if (activeWindow) {
        activeWindow.classList.add('active-window');
      }
    }

    function setSelectedWindow(window: HTMLElement | null) {
      windows.forEach(w => w.classList.remove('selected-window'));
      selectedWindow = window;
      if (selectedWindow) {
        selectedWindow.classList.add('selected-window');
      }
    }

    // Window management with keyboard
    document.addEventListener('keydown', (e) => {
      if (!activeWindow && !selectedWindow) return;

      const workspace = document.querySelector<HTMLElement>('main');
      if (!workspace) return;
      
      // Select windows with Shift + Arrow keys
      if (e.shiftKey) {
        e.preventDefault();
        const currentWindow = selectedWindow || activeWindow;
        if (!currentWindow) return;

        const currentRect = currentWindow.getBoundingClientRect();
        const otherWindows = Array.from(windows).filter(w => w !== currentWindow);
        
        let nextWindow: HTMLElement | null = null;
        let minDistance = Infinity;

        otherWindows.forEach(window => {
          const rect = window.getBoundingClientRect();
          
          switch (e.key) {
            case 'ArrowLeft': {
              if (rect.right < currentRect.left && 
                  rect.top < currentRect.bottom && 
                  rect.bottom > currentRect.top) {
                const distance = currentRect.left - rect.right;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
            case 'ArrowRight': {
              if (rect.left > currentRect.right && 
                  rect.top < currentRect.bottom && 
                  rect.bottom > currentRect.top) {
                const distance = rect.left - currentRect.right;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
            case 'ArrowUp': {
              if (rect.bottom < currentRect.top && 
                  rect.left < currentRect.right && 
                  rect.right > currentRect.left) {
                const distance = currentRect.top - rect.bottom;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
            case 'ArrowDown': {
              if (rect.top > currentRect.bottom && 
                  rect.left < currentRect.right && 
                  rect.right > currentRect.left) {
                const distance = rect.top - currentRect.bottom;
                if (distance < minDistance) {
                  minDistance = distance;
                  nextWindow = window;
                }
              }
              break;
            }
          }
        });

        if (nextWindow) {
          setSelectedWindow(nextWindow);
          setActiveWindow(nextWindow);
        }
      }

      // Move windows with Alt + Arrow keys
      if (e.altKey) {
        e.preventDefault();
        const targetWindow = selectedWindow || activeWindow;
        if (!targetWindow) return;

        switch (e.key) {
          case 'ArrowLeft':
            swapWithNeighbor(targetWindow, 'left');
            break;
          case 'ArrowRight':
            swapWithNeighbor(targetWindow, 'right');
            break;
          case 'ArrowUp':
            swapWithNeighbor(targetWindow, 'up');
            break;
          case 'ArrowDown':
            swapWithNeighbor(targetWindow, 'down');
            break;
        }
      }
      
      // Resize windows with Ctrl + Arrow keys
      if (e.ctrlKey) {
        e.preventDefault();
        const targetWindow = selectedWindow || activeWindow;
        if (!targetWindow) return;

        const action = {
          ArrowLeft: 'shrink-width',
          ArrowRight: 'grow-width',
          ArrowUp: 'shrink-height',
          ArrowDown: 'grow-height'
        }[e.key] as 'grow-width' | 'shrink-width' | 'grow-height' | 'shrink-height';

        if (action) {
          resizeWindowByPercent(targetWindow, action);
        }
      }
    });

    function swapWithNeighbor(window: HTMLElement, direction: 'left' | 'right' | 'up' | 'down') {
      const rect = window.getBoundingClientRect();
      const neighbors = Array.from(windows).filter(w => w !== window);
      
      // Find the closest neighbor in the specified direction
      const neighbor = neighbors.reduce((closest, current) => {
        const currentRect = current.getBoundingClientRect();
        
        // Check if the window is in the correct direction
        const isValidDirection = (
          (direction === 'left' && currentRect.right <= rect.left) ||
          (direction === 'right' && currentRect.left >= rect.right) ||
          (direction === 'up' && currentRect.bottom <= rect.top) ||
          (direction === 'down' && currentRect.top >= rect.bottom)
        );

        if (!isValidDirection) return closest;

        // Calculate distance between windows
        const distance = Math.hypot(
          (currentRect.left + currentRect.width/2) - (rect.left + rect.width/2),
          (currentRect.top + currentRect.height/2) - (rect.top + rect.height/2)
        );

        return (!closest || distance < closest.distance) ? { element: current, distance } : closest;
      }, null as { element: HTMLElement, distance: number } | null);

      if (neighbor) {
        // Swap positions with the neighbor
        const windowPos = {
          left: window.style.left,
          top: window.style.top,
          width: window.style.width,
          height: window.style.height
        };

        const neighborElement = neighbor.element;
        window.style.left = neighborElement.style.left;
        window.style.top = neighborElement.style.top;
        window.style.width = neighborElement.style.width;
        window.style.height = neighborElement.style.height;

        neighborElement.style.left = windowPos.left;
        neighborElement.style.top = windowPos.top;
        neighborElement.style.width = windowPos.width;
        neighborElement.style.height = windowPos.height;
      }
    }

    function resizeWindowByPercent(window: HTMLElement, action: 'grow-width' | 'shrink-width' | 'grow-height' | 'shrink-height') {
      const workspace = document.querySelector<HTMLElement>('main')!;
      const workspaceRect = workspace.getBoundingClientRect();
      const rect = window.getBoundingClientRect();
      const percent = 0.05; // 5% change

      // Find all windows that will be affected by this resize
      const others = Array.from(windows).filter(w => w !== window) as HTMLElement[];
      
      // Calculate the resize amount
      const resizeAmount = action.includes('width') 
        ? workspaceRect.width * percent 
        : workspaceRect.height * percent;

      // Apply resize to all affected windows
      if (action.includes('width')) {
        // Only affect windows in the same row
        const sameRowWindows = others.filter(w => {
          const r = w.getBoundingClientRect();
          return Math.abs(r.top - rect.top) < gaps && Math.abs(r.height - rect.height) < gaps;
        });

        if (action === 'grow-width') {
          const rightWindows = sameRowWindows.filter(w => {
            const r = w.getBoundingClientRect();
            return Math.abs(r.left - rect.right) <= gaps;
          });
          
          if (rightWindows.length > 0) {
            window.style.width = `${rect.width + resizeAmount}px`;
            rightWindows.forEach(w => {
              const r = w.getBoundingClientRect();
              w.style.left = `${r.left + resizeAmount}px`;
              w.style.width = `${r.width - resizeAmount}px`;
            });
          }
        } else {
          const rightWindows = sameRowWindows.filter(w => {
            const r = w.getBoundingClientRect();
            return Math.abs(r.left - rect.right) <= gaps;
          });
          
          if (rightWindows.length > 0 && rect.width > 300) {
            const shrinkAmount = Math.min(resizeAmount, rect.width - 300);
            window.style.width = `${rect.width - shrinkAmount}px`;
            rightWindows.forEach(w => {
              const r = w.getBoundingClientRect();
              w.style.left = `${r.left - shrinkAmount}px`;
              w.style.width = `${r.width + shrinkAmount}px`;
            });
          }
        }
      } else {
        // Only affect windows in the same column
        const sameColumnWindows = others.filter(w => {
          const r = w.getBoundingClientRect();
          return Math.abs(r.left - rect.left) < gaps && Math.abs(r.width - rect.width) < gaps;
        });

        if (action === 'grow-height') {
          const bottomWindows = sameColumnWindows.filter(w => {
            const r = w.getBoundingClientRect();
            return Math.abs(r.top - rect.bottom) <= gaps;
          });
          
          if (bottomWindows.length > 0) {
            const newHeight = rect.height + resizeAmount;
            window.style.height = `${newHeight}px`;
            
            bottomWindows.forEach(w => {
              const r = w.getBoundingClientRect();
              w.style.top = `${rect.bottom + gaps}px`;
              w.style.height = `${r.height - resizeAmount}px`;
            });
          }
        } else if (action === 'shrink-height') {
          const bottomWindows = sameColumnWindows.filter(w => {
            const r = w.getBoundingClientRect();
            return Math.abs(r.top - rect.bottom) <= gaps;
          });
          
          if (bottomWindows.length > 0 && rect.height > 200) {
            const shrinkAmount = Math.min(resizeAmount, rect.height - 200);
            window.style.height = `${rect.height - shrinkAmount}px`;
            
            bottomWindows.forEach(w => {
              const r = w.getBoundingClientRect();
              w.style.top = `${rect.bottom - shrinkAmount + gaps}px`;
              w.style.height = `${r.height + shrinkAmount}px`;
            });
          }
        }
      }
    }

    function isInResizePath(rect1: DOMRect, rect2: DOMRect, action: string) {
      const tolerance = gaps;

      if (action.includes('width')) {
        // Check if windows are vertically aligned
        const verticalOverlap = !(rect1.bottom < rect2.top - tolerance || rect1.top > rect2.bottom + tolerance);
        
        if (action === 'grow-width') {
          // Check if window2 is to the right of window1
          return verticalOverlap && Math.abs(rect2.left - rect1.right) <= tolerance;
        } else {
          // Check if window2 is to the right of window1
          return verticalOverlap && Math.abs(rect2.left - rect1.right) <= tolerance;
        }
      } else {
        // Check if windows are horizontally aligned
        const horizontalOverlap = !(rect1.right < rect2.left - tolerance || rect1.left > rect2.right + tolerance);
        
        if (action === 'grow-height') {
          // Check if window2 is below window1
          return horizontalOverlap && Math.abs(rect2.top - rect1.bottom) <= tolerance;
        } else {
          // Check if window2 is below window1
          return horizontalOverlap && Math.abs(rect2.top - rect1.bottom) <= tolerance;
        }
      }
    }

    // Initial window layout
    setTimeout(() => {
      const windowArray = Array.from(windows);
      if (windowArray.length >= 4) {
        setActiveWindow(windowArray[0]);
        
        // Set up initial grid layout with consistent gaps
        const gaps = 8; // Reduced gap size for better space utilization
        const layout = [
          { 
            left: `${gaps}px`, 
            top: `${gaps}px`, 
            width: `calc(50% - ${gaps * 1.5}px)`, 
            height: `calc(50% - ${gaps * 1.5}px)` 
          },
          { 
            left: `calc(50% + ${gaps/2}px)`, 
            top: `${gaps}px`, 
            width: `calc(50% - ${gaps * 1.5}px)`, 
            height: `calc(50% - ${gaps * 1.5}px)` 
          },
          { 
            left: `${gaps}px`, 
            top: `calc(50% + ${gaps/2}px)`, 
            width: `calc(50% - ${gaps * 1.5}px)`, 
            height: `calc(50% - ${gaps * 1.5}px)` 
          },
          { 
            left: `calc(50% + ${gaps/2}px)`, 
            top: `calc(50% + ${gaps/2}px)`, 
            width: `calc(50% - ${gaps * 1.5}px)`, 
            height: `calc(50% - ${gaps * 1.5}px)` 
          }
        ];

        windowArray.forEach((window, i) => {
          if (i < layout.length) {
            Object.assign(window.style, layout[i]);
          }
        });
      }
    }, 100);
  });
</script>